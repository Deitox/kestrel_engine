# Engine Polish Targets

## Automated GPU Baselines & Alerts
- **Status:** [x] Completed via `cargo run --bin gpu_baseline` harness + `scripts/ci/run_gpu_baseline.ps1` and the GitHub Action step that uploads diffs.
- **Goal:** Catch regressions in Shadow/Mesh/Sprite passes automatically now that analytics exposes GPU timings.
- **Scope:** Deterministic headless runner loads the canned scene, renders N frames, writes `perf/gpu_baseline.json`, and compares to a checked-in baseline with per-pass tolerances; CI invokes it and fails on drift.
- **Implementation Notes:**
  - `GpuTimingAccumulator` serializes pass summaries and the `gpu_baseline` binary reuses the full scene-loading path so sprites/meshes match editor behavior.
  - `scripts/ci/run_gpu_baseline.ps1` wraps the binary for CI; `.github/workflows/animation-bench.yml` runs it after perf suite and publishes the artifact.
  - Future updates refresh `perf/gpu_baseline.json` to tighten tolerances as optimizations land.

## Cascaded Shadow Refinement
- **Status:** [x] Completed by threading cascade controls through `SceneShadowData`, `config/app.json`, and the editor lighting panel.
- **Goal:** Close Milestone 12's "advanced lighting" bullet by exposing cascade controls and adding PCF filtering for distant cascades.
- **Scope:** Promote cascade configuration (count, splits, resolution, PCF radius) into `SceneShadowData` / `config/app.json`, update the lighting panel to edit those values, and implement adaptive split computation per camera.
- **Implementation Notes:**
  - The renderer now blends uniform and logarithmic cascade splits per camera, uploads per-cascade texel sizes/PCF radii, and re-allocates the shadow map array whenever cascade counts or resolution change.
  - `ShadowUniform`/`sample_shadow` include comparison-sampler PCF filtering with per-cascade radii to suppress shimmer.
  - Scene metadata + config persist cascade knobs so CI/editor captures stay deterministic.

## Sprite Zoom Guardrails
- **Status:** [x] Completed with configurable zoom limits + sprite footprint checks.
- **Goal:** Prevent the editor from rasterizing enormous quads when zooming too far into sprites.
- **Scope:** Expose camera zoom limits in config/editor UI, detect when sprites exceed a target on-screen size, and either warn or auto-clamp zoom; optionally add an LOD path for oversize sprites.
- **Implementation Notes:**
  - Added `editor` config + UI sliders for min/max orthographic zoom, sprite guardrail thresholds, and guard modes (Off/Warn/Clamp/Strict) so artists can tune limits live.
  - Sprite batching now measures each instance's on-screen footprint via `Camera2D::world_rect_to_screen_bounds`; warn or auto-clamp zoom when pixels exceed the threshold, or hide offending sprites entirely when guardrails are `Strict`.
  - Guardrail feedback surfaces directly in the Camera pane so users understand when zoom clamping/culling just occurred.

## Build & Benchmark Harness
- **Status:** [x] Completed via `scripts/run_perf_suite.py` and the expanded `.github/workflows/animation-bench.yml` step that publishes the suite artifact.
- **Goal:** Deliver Milestone 14's "one command" perf suite by orchestrating `sprite_bench.py --runs 3` and `capture_sprite_perf.py`.
- **Scope:** Provide `scripts/run_perf_suite.py` that forwards shared CLI knobs, runs both helpers, captures their artifacts, and emits a combined JSON summary with optional baseline diffing.
- **Implementation Notes:**
  - Supports shared knobs such as `--sprite-baseline`, `--count`, `--steps`, and existing bench/capture overrides so CI/local workflows do not need to touch the original helpers.
  - The workflow now executes `python scripts/run_perf_suite.py --label ci_perf_suite ...` after the animation targets measurement and uploads the resulting `perf/ci_perf_suite_*` artifacts.
  - Existing helper scripts remain standalone; the suite simply coordinates them for CI and local automation.

## Plugin Sandboxing Roadmap
- **Status:** [ ] Phase 3b underway (event RPC flowing; ECS queries/assets pending)
- **Goal:** Provide a concrete plan for Milestone 13's stretch goal: isolating untrusted plugins.
- **Scope:** Define capability metadata in `config/plugins.json`, gate `PluginContext` APIs by declared capabilities, log capability grants in `PluginStatus`, and design an out-of-process host for `trust = "isolated"` entries.
- **Implementation Notes:**
    - **Capability taxonomy:** implemented enum-based capability metadata (`renderer`, `ecs`, `assets`, `input`, `scripts`, `analytics`, `time`, `events`) plus manifest validation. Built-ins default to full access, while third-party entries must declare the capabilities they need.
    - **API gating:** `PluginContext` enforces capability checks on every mutating accessor and emits `CapabilityError`s (plus analytics events) when a plugin asks for something it wasn’t granted. Tests cover the gating path so regressions are caught in CI.
    - **Telemetry + surfacing:** capability grants/violations are visible in both the plugin manifest UI (per-plugin rows show trusted caps + violation counts) and the analytics "Stats" panel, which now lists recent violations captured via the Analytics plugin.
    - **Pipe-based RPC harness:** `plugin_rpc.rs` defines the bincode/framed protocol shared by the engine and `kestrel_plugin_host`. The host now loads the target cdylib, services `build/update/fixed_update/on_events/shutdown` requests received over anonymous pipes, and mirrors plugin errors back to the editor UI.
    - **Isolated proxy integration:** `PluginManager` launches `kestrel_plugin_host` whenever `"trust": "isolated"` is set, and the proxy now captures emitted events from the host, re-injecting them into the editor ECS so `ctx.emit_event`/`ctx.emit_script_message` work for isolated plugins. The same transport now exposes a read-only ECS query endpoint plus watchdog timers so hung hosts are torn down deterministically.
    - **Developer tooling:** the new `isolated_plugin_cli` binary loads a manifest entry, runs a headless update loop, prints emitted events, and can issue RPC entity-info probes for quick validation/fuzzing outside the editor.
    - **Phased rollout:** Phase 1 (cap metadata + gating) and Phase 2 (analytics/UI surfacing) are complete. Phase 3a (RPC loop + lifecycle calls) shipped previously; Phase 3b (event RPC + ECS query plumbing + CLI + regression tests) is now in progress, and Phase 3c will fold in asset readbacks plus watchdog-triggered recovery before making isolation the default.
    - **Phase 3b priority:** Expand the read-only ECS surface first—add component-specific query RPCs for sprites/transforms and a lightweight filtered entity iterator so isolated plugins can inspect state without fabricating events. Once that ships, move on to asset readbacks (atlas metadata/binary blobs) and wire watchdog failures into `PluginStatus` so artists immediately see when the sandbox killed a plugin.
    - **Read-only ECS RPC design:** Introduce a `PluginRpc::ReadComponents` request that accepts an `EntityId`, `ComponentSet` (enum list of `Sprite`, `Transform2D`, `Hierarchy`, etc.), and `SnapshotFormat` (`Full`, `Partial`, `Lite`). The response sends back a `ComponentSnapshot` array with strongly typed payloads (`SpriteSnapshot { atlas_id, frame_index, color, visibility, flip_flags }`, `TransformSnapshot { translation, rotation, scale, parent }`, `HierarchySnapshot { parent, children_count }`) so plugins do not need to parse raw ECS pages. For bulk queries, add `PluginRpc::IterEntities` with a `Filter` (component mask, optional tag/event-derived filters) plus a `cursor` token and `limit`. The host responds with `{ entities: Vec<EntityId>, snapshots: Vec<ComponentSnapshot>, next_cursor }` so isolated plugins can page through matching entities without exhausting the pipe.
    - **Host/engine plumbing:** `PluginManager::handle_rpc_request` needs stubs that fork read-only ECS access onto the main thread: look up the entity, serialize the requested components via the existing reflection helpers, and honor `Capability::Ecs` (fail fast with `CapabilityError` otherwise). On the host side, add non-blocking helpers (`ctx.read_sprite(entity_id)`, `ctx.iter_entities(filter)`) that wrap the new RPCs internally, expose ergonomic iterators to plugin authors, and document that reads are snapshots (no live references). For pagination, store the iterator state in `PluginProxy::pending_iters` keyed by `cursor` so the engine can release archetype borrows between calls.
    - **Asset readbacks + watchdog UX:** After ECS reads land, extend the RPC enum with `AssetReadback` (supporting `AtlasMeta`, `BlobHandle`, `BinaryRange` types) so isolated plugins can fetch sprite atlas metadata or raw asset blobs without touching disk. Surface watchdog kills by emitting a `PluginStatus::WatchdogTripped` record that `PluginStatusPanel` renders inline (badge + tooltip + retry affordance) and mirror the event into analytics for alerting. The kill record should include `reason`, `elapsed_ms`, and `last_request` to help artists triage flaky plugins; follow-up work wires the watchdog channel into the CLI so headless plugin runs can fail fast with actionable logs.
    - **RPC sequencing + validation:** Define the on-wire structs next to `plugin_rpc.rs` and add snapshot serialization helpers (`impl From<&SpriteComponent> for SpriteSnapshot`). Include forward/backward-compatible version tags plus per-request `request_id` fields so the host can correlate retries after watchdog resets. Add integration tests that spin up `kestrel_plugin_host` under `cargo test -p isolated_plugin_cli` and assert that `ReadComponents` returns deterministic JSON fixtures for canned ECS worlds.
    - **Sample plugin + docs:** Create a `sprite_probe` sample plugin (isolated, read-only caps only) that issues both RPCs to dump all entities tagged `actor`. Use it as the canonical example inside `docs/plugins/isolation.md`, highlighting the snapshot format, pagination, and error handling so third parties know how to migrate.
    - **Incremental rollout:** Guard the new RPCs behind a feature flag (`enable_isolated_ecs_reads`) in `config/plugins.json` until QA finishes. Phase the rollout: (1) land the engine RPCs + host helpers, (2) ship the sample plugin and CLI validation path, (3) add asset readbacks, (4) enable watchdog UI surfacing, (5) flip the feature flag by default after perf soak + analytics confirm no regressions.
    - **Asset readback transport:** Extend `PluginRpc` with `AssetReadback { request_id, payload: AssetReadbackRequest }` where the payload supports `AtlasMeta { atlas_id }`, `AtlasBinary { atlas_id }`, and `BlobRange { blob_id, offset, length }`. Responses include a `content_type` hint, byte length, and, for metadata, a JSON blob describing frame rects/pivots/hash so plugins can diff. Enforce `Capability::Assets` checks and require manifests to declare `asset_filters` (`{"atlases": ["ui/*", "fx/fire"]}`) so isolated plugins cannot enumerate arbitrary project files.
    - **Asset cache + throttling:** Add a shared `IsolatedAssetCache` on the engine side backed by LRU entries keyed on `(asset_id, range)` to avoid reloading the same atlas per frame. Rate-limit readbacks via `AssetReadbackBudget` (e.g., 8 requests / frame, 4 MB total) and return a structured `RateLimited` error when exceeded; `kestrel_plugin_host` should translate this into a `PluginError::Throttled` with guidance.
    - **Watchdog surfacing:** When `PluginProxy` restarts a host due to the watchdog, push a `PluginStatusEvent::WatchdogTripped { reason, elapsed_ms, last_request }` onto the shared status channel. `PluginStatusPanel` renders a yellow badge inline with retry/dismiss controls, and clicking the badge opens a drawer showing the last 10 watchdog events plus the offending RPC. Emit a matching analytics event (`plugin_watchdog_tripped`) so Ops can alert on spikes.
    - **CLI + automation hooks:** `isolated_plugin_cli` gains `--watchdog-ms` and `--asset-readback` flags so CI can simulate slow plugins and asset fetches. On watchdog trip, the CLI exits non-zero with the structured cause; asset readback throttling logs a warning but continues unless `--fail-on-throttle` is set. These hooks let QA automate regression tests before the feature flag flips.
    - **PluginStatus UX wiring:** `PluginStatusPanel` now renders inline `ECS`/`Asset` badges, shows a collapsible "Read-only ECS" history (fed by the new manager-side query log), summarizes per-plugin asset readback metrics, and exposes a "Retry asset readback" button that replays the last request and reports the byte count/content type. The `isolated_plugin_cli` also gained `--watchdog-ms`, `--asset-readback kind=value`, and `--fail-on-throttle` flags so automation can simulate watchdog trips and asset fetches directly.
    - **Atlas metadata schema:** Document the atlas metadata JSON in `docs/plugins/asset_readbacks.md`, covering frame rects, pivot offsets, texel size, and checksum fields. Provide TypeScript/Rust helper structs so plugin authors can deserialize safely, and add an `atlas_meta_schema.json` fixture that tests can validate against.
    - **Security considerations:** Call out in the docs that asset readbacks respect manifest filters and are subject to audit logging. Add an `analytics::plugin_asset_readback` event that captures plugin id, asset id, byte count, and duration so suspicious usage can be investigated.
